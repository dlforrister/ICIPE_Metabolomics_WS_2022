---
title: "Definging XCMS Parameters"
author: "Dale Forrister"
date: "2022-09-14"
output: html_document
---
Install IPO
```{r setup, include=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE)) { 
    install.packages("BiocManager")}

if (!requireNamespace("IPO", quietly=TRUE)) { 
    BiocManager::install("IPO")}

# for examples of peak picking parameter optimization:

if (!requireNamespace("msdata", quietly=TRUE)) { 
    BiocManager::install("msdata")}

# for examples of optimization of retention time correction and grouping
# parameters:
if (!requireNamespace("faahKO", quietly=TRUE)) { 
    BiocManager::install("faahKO")}

if (!require(here)) {install.packages('here')}



library(IPO)
library(here)
here::here()
```


Raw Data
```{r}
datapath <- system.file("cdf", package = "faahKO")
datafiles <- list.files(datapath, recursive = TRUE, full.names = TRUE)

datafiles <- list.files(here("test_data","Standard"),full.names = TRUE)



```
#Optimization of peak picking parameters 

Peak picking with XCMS identifies peakings within chromatographic data.

There are two main algarithims: centWave (2008) and matchedFilter (2006). 

Both algarithms work for centroided data. 
  matchedFilter is designed for lowwer mass resolution datasets. 
  centWave, is updated and optimized for high mass accuracy datasets. 
  
Here we will focus on centWave:

We need to define the following key parameters:
  ppm: numeric(1) defining the maximal tolerated m/z deviation in consecutive scans in parts per million (ppm) for the initial ROI definition.
        
      All mass specs have scan to scan variation in mass accuracy. A smaller ppm error will  split mz values (ions) that are similar in mass, higher values will lump more together. Typrical value for a high resolution mass sectrometer (orbitrap or qTof ~  5-10 ppm) 
  
  peakwidth: numeric(2) with the expected approximate peak width in chromatographic space. Given as a range (min, max) in seconds.
      
      This parameter is determined by the chromatographic separation of your data. This depends on the gradient you use, the column and the pressure. HPLC- high pressure liquid chromography will have wider peaks whereas UPLC-ultra high pressure liquid chromotography will have more resolution and narrower peaks. Typical values for UPLC are 4 to 15 seconds per peak
    
  snthresh: numeric(1) defining the signal to noise ratio cutoff.
  
            This depends on the sensativity of the instrument. Instruments that are more sensative will ahve a lower baseline noise level and higher intensity for actual peaks, thus a larger signal to noise ratio. For qTof a value of 5 is typcially appropriate. 
  
  
  prefilter
  noise: numeric(1) allowing to set a minimum intensity required for centroids to be considered in the first analysis step (centroids with intensity < noise are omitted from ROI detection).

  This largely depends on the noise of the instrument. What is the minimun value of a single scan for a good feature? qTof this is typically 10e3 or 10e34. Minimun of 750 typically works as a lower threshold 
  
cwparam <- CentWaveParam(ppm=15, peakwidth=c(4,12), snthresh=5, prefilter=c(10,500))

```{r, include=FALSE}

peakpickingParameters <- getDefaultXcmsSetStartingParams('centWave')
peakpickingParameters <- getDefaultXcmsSetStartingParams('matchedFilter')


#setting levels for ppm to 10 and 30 (hence 20 is the center point)
peakpickingParameters$ppm <- c(10, 30)

#peak width requires two values min and max. 
#setting levels for min_peakwidth to 2 and 10 
peakpickingParameters$min_peakwidth <- c(2, 8)

#setting levels for max_peakwidth to 10 and 20 
peakpickingParameters$max_peakwidth <- c(10, 20)

#setting levels for snthresh to 2 and 10
peakpickingParameters$snthresh <- c(10, 20)

#setting levels for noice to 500 and 1000
peakpickingParameters$noise <- c(500, 1000)

#prefilter also has two vlaues the number of scans (k) and min intensity (I). Because we are optimizing noise, we can ignore I. 

peakpickingParameters$prefilter <- c(2, 10)


#setting only one value for mzdiff therefore this parameter is not optimized and we will use the default
peakpickingParameters$mzdiff <- -0.001

peakpickingParameters

```
Here we optimize and visualize the results
```{r}

time.xcmsSet <- system.time({ # measuring time
resultPeakpicking <- 
  optimizeXcmsSet(files = datafiles[1:2], 
                  params = peakpickingParameters, 
                  nSlaves = 1, 
                  subdir = NULL,
                  plot = TRUE)
})
```



```{r}

```

```{r}

```

```{r}

```

```{r}

```
