---
title: "Introduction to LC-MS data preprocessing with XCMS"
author: "Dale L. Forrister"
affiliation: "School of Biological Sciences, University of Utah"
date: "9/16/2022"
contact: "dlforrister@gmail.com"
output: html_document
---

# **1.0 Goals**

The goal of this exercise is to go over preprocessing of (untargeted) LC-MS data using the xcms package (Smith et al. 2006). The preprocessing comprises chromatographic peak detection, sample alignment and peak grouping. The output will be a feature table that quantifies the intensity of each feature in each sample. The main goal of this exercize is to go over key parameters that need to be adjusted for the most important settings of the most commonly used preprocessing methods.

This excersize has been adapted from a workshop created by Johannes Rainer in 2019 (<https://jorainer.github.io/metabolomics2018/xcms-preprocessing.html#31_Data_import_and_representation>)

# **2.0 Introduction to Feature Based Molecular Networking - FBMN.**

In order to work with LC-MS data it must be converted from vendor specific formats to an open source format, most commonly "mzXML" or "mzML" files. This is not covered in the tutorial but see proteowizard for more details - <https://proteowizard.sourceforge.io/tools/msconvert.html>) for more details on conversion.

## **2.1 Required Packages**

Most packages used in metabolomics are maintained via Bioconductor, and thus need to be installed with "BiocManager"

The analysis in this document requires an R version \>= 4.0.0 and recent versions of the MSnbase and xcms (version \>= 3.11.3 is needed) packages. The packages can be installed with:

```{r packages, include=FALSE}

if (!requireNamespace("BiocManager", quietly=TRUE)) { 
    install.packages("BiocManager")}


if (!requireNamespace("xcms", quietly=TRUE)) { 
    BiocManager::install("xcms")}

library(xcms)

if (!requireNamespace("CAMERA", quietly=TRUE)) { 
    BiocManager::install("CAMERA")}

library(xcms)


```

In this tutorial we will also use the here package in order to simpify file paths when working with R projects and R markdown files.

```{r filepaths}
if (!require(dplyr)) {install.packages('dplyr')}

library(dplyr)

if (!require(here)) {install.packages('here')}

library(here)
here()
```

## **2.2 what are LC-MS and LC-MSMS data?**

Mass spectrometry allows to measure abundances of charged molecules (ions) in a sample. Abundances are determined as ion counts for a specific mass-to-charge ratio m/z. The measured signal is represented as a ***mass*** ***spectrum***, which is composed of different ***mass peaks*** defined by their m/z with different intensities.

[![Johannes Rainer](images/ms_scan.png)](https://jorainer.github.io/metabolomics2018/xcms-preprocessing.html#31_Data_import_and_representation)

Many ions have the same or a very similar m/z making it difficult or impossible to discriminate them. MS is thus frequently coupled with a second technology to separate analytes based on other properties than their mass (or rather m/z). Common choices are gas chromatography (GC) or liquid chromatography (LC).

[![Johannes Rainer](images/LC_MS.png)](https://jorainer.github.io/metabolomics2018/xcms-preprocessing.html#31_Data_import_and_representation)

Thus, the basic unit of LC-MS data is a scan, which corresponds to a mass spectrum at a specific time point. Each spectrum contains the relative abundance of each m/z (ion) at that specific instance or scan. LC-MS data is therefore a **time series of mass spectra**. By coupling the RT and the m/z values we are able to separate metabolites that would otherwise be indistinguishable based only on their m/z values.

Understanding the what LC-MS data are is useful for the rest of this excersize, because the preprocessing steps of untargeted metbolomics analysis are specifically designed to convert a time series of spectra, into a feature x abundance matrix. Knowing the structure of the data makes setting key parameters much more intuitive.

# 3.0 Workflow: FBMN data preprocessing using XCMS

We go through the following steps:

1)  data handling (I/O) of mass spectrometry data, which relies on the MSnbase package. (Section 3.1)

2)  [*chromatographic peak detection*]{.underline}: process in which chromatographic peaks are identified within each file. (Section 3.3)

3)  [*retention time alignment*]{.underline}: process that adjusts for retention time differences between measurements/files. (Section 3.4)

4)  [*correspondence*]{.underline}: grouping of chromatographic peaks (presumably from the same ion) across files (Section 3.5)

5)  [*gap filling*]{.underline}: Once all features have been identified across all samples, we quantify their abundance in each sample (Section 3.6)

## 3.1 Data important

### The dataset

The example data set of this workflow consists of five files in mzML format with signals from retention time index (RTI) samples. An RTI is a type of external standard containing known compounds that are run at the start, in the middle and at the end of an experiment. The RTI is then used to track machine variation across the run in terms of shift in retention time and mass signal.

![](images/Chromatogram_1.JPG)

Data were acquired on a Waters Xevo G2 QToF coupled to an Waters Acquity I-Class UPLC with a waters 2.1 x 50 mm BEH C18 column. Data were aquired in negative ionization mode. A 15 minute reverse-phase gradient was used with water (0.1% formic acid) as the mobile phase and acetonitrile (0.1% formic acid) as the stationary phase.

### Data import

In the code block below we first define the location of the mzML files, which are part of the `msdata` package. We also define a `data.frame` describing the samples/experiment and pass this to the `readMSData` function which imports the data. The option `mode = "onDisk"` tells the function to read only general metadata into memory. The m/z and intensity values are not imported but retrieved from the original files on demand, which enables also analyses of very large experiments.

```{r}

datafiles <- list.files(here("data", "FBMN_Example" ),pattern = ".mzML",full.names = TRUE) 


sample_meta <- read.csv(here("data", "FBMN_Example","sample_metadata.csv"))
sample_meta


pd <- data.frame(file_path= here("data", "FBMN_Example",sample_meta$file_name),
                 file = sample_meta$file_name,
                injection_idx = sample_meta$injection_order,
                 sample = gsub(".mzML","",sample_meta$file_name),
                 group = sample_meta$sample_type)

#add 2772 or remove it9

rawData <- readMSData(pd$file_path, pdata = new("NAnnotatedDataFrame", sample_meta), centroided. = TRUE,mode= "onDisk", verbose=T)

rawData


```

The MS experiment data is now represented as an `OnDiskMSnExp` object. Phenotype information can be retrieved with the `pData` function, single columns in the phenotype table using `$`. Below we access sample descriptions.

```{r}


pData(rawData)
```

## 

## 3.2 **Chromatographic peak detection**

```{r}

cwp <- CentWaveParam(peakwidth = c(2, 10), ppm=15, integrate = 2, noise=500, snthresh=0)

rawData <- findChromPeaks(rawData, param = cwp)

```

## [*3.3 retention time alignment:*]{.underline}

```{r}

#' Define the settings for the initial peak grouping - details for
#' choices in the next section.
pdp <- PeakDensityParam(sampleGroups = pData(rawData)$sample_type, bw = 30,
                        minFraction = 1, binSize = 0.05)

rawData <- groupChromPeaks(rawData, pdp)


#' Define settings for the alignment
pgp <- PeakGroupsParam(minFraction = 0.1, span = 0.6,subset = which(pData(rawData)$sample_type == "Standard"))

#pgp <- PeakGroupsParam(minFraction= 0.001, extraPeaks = 100,smooth="loess", span = 1,  subset = which(pData(rawData)$sample_type == "Standard"),subsetAdjust = "previous")

rawData <- adjustRtime(rawData, param = pgp) 





```

## **3.4 Correspondence (Peak Grouping)**

```{r}


pdp <- PeakDensityParam(sampleGroups = pData(rawData)$sample_type, bw=4, binSize=0.25, minSamples=1, minFraction = 0.001)

rawData <- groupChromPeaks(rawData, param = pdp) 

```

## 3.6 Gap Filling

```{r}
rawData <- fillChromPeaks(rawData, param = ChromPeakAreaParam())


```

\### Export data

#### export MS1 and MS2 features

Below we use the \`featureSpectra\` function to extract all MS2 spectra with their

precursor m/z being within the m/z range of a feature/peak and their retention

time within the rt range of the same feature/peak. Note that for older \`xcms\`

versions (i.e. before version 3.12) \`return.type = "Spectra"\` has to be used

instead of \`return.type = "MSpectra"\` as in the example below. Zero-intensity

values are removed from each spectrum with the \`clean\` function, and

subsequently processed into the expected format using the \`formatSpectraForGNPS\`

function.{r}

```{r}
register(SerialParam(), default=TRUE)


RTI_data_files <- filterFile(
  rawData,which(pData(rawData)$sample_type == "Standard"))

standards_post <- chromatogram(RTI_data_files, aggregationFun = "max",rt = c(0, 700))
plot(standards_post, peakType = "none")
```

```{r}


source("https://raw.githubusercontent.com/jorainer/xcms-gnps-tools/master/customFunctions.R"))

## export the individual spectra into a .mgf file

filteredMs2Spectra <- featureSpectra(rawData, return.type = "MSpectra")

filteredMs2Spectra <- clean(filteredMs2Spectra, all = TRUE)

filteredMs2Spectra <- formatSpectraForGNPS(filteredMs2Spectra)



```


